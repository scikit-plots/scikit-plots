## scikit-plots/meson.build
## Building C/C++/Rust/native extensions or full native projects

# Authors: The scikit-plots developers
# SPDX-License-Identifier: BSD-3-Clause

######################################################################
## Project
## https://mesonbuild.com/Syntax.html#syntax
######################################################################

# Project configuration
project(
  'scikit-plots',
  'c', 'cpp', 'cython', #'python',
  # Note that the git commit hash cannot be added dynamically here
  # That only happens when importing from a git repository.
  # See `scikitplot/__init__.py`
  version: run_command(
    # ['python', 'scikitplot/_build_utils/version.py'],
    # This should become `scikitplot/_version.py` in 'scikit-plots'
    ['scikitplot/_build_utils/gitversion.py'],
    check: true,
  ).stdout().strip(),
  meson_version: '>= 1.5.0',
  license: 'BSD-3-Clause',                      # Valid SPDX license expression: 'MIT', 'Apache-2.0', 'GPL-3.0-or-later'
  # license-files: ['LICENSE.txt', 'LICEN[CS]E*/*'],  # list[file] COPYING, COPYRIGHT
  default_options: [
    'b_ndebug=if-release',
    'buildtype=debugoptimized',
    'pkgconfig.relocatable=true',
    'c_std=c17',                     # Set C standard to C17
    'cpp_std=c++17',                 # Set C++ standard to C++17
    # 'fortran_std=legacy',          # ERROR 'none'
    # 'blas=openblas',               # 'scipy-openblas'
    # 'lapack=openblas',             # 'scipy-openblas'
    # https://mesonbuild.com/Builtin-options.html#details-for-warning_level
    # 'warning_level=3',             # You can specify warning levels here if needed
    # 'werror=true',                 # Treat warnings as errors globally
  ],
)
release_version = meson.project_version()

## Add .tarball-version during `meson dist`
meson.add_dist_script(
  'bash', '-c',
  'echo @0@ > "$MESON_DIST_ROOT/.tarball-version"'.format(release_version)
)

## Get the directory relative to the top-level project directory
# project_root = meson.project_source_root()

## Get the directory relative to the current meson.build file
# current_dir = meson.current_source_dir()

## Get the directory relative to the build directory
# build_dir = meson.current_build_dir()

######################################################################
## ANSI colors
######################################################################

## ANSI colors for pretty output
BOLD='\033[1m'
RESET='\033[0m'
RED='\033[1;31m'
GREEN='\033[1;32m'
BLUE='\033[1;34m'
YELLOW='\033[1;33m'
MAGENTA='\033[1;35m'
CYAN='\033[1;36m'

######################################################################
## BLAS/LAPACK dependency
######################################################################

# TODO: 64-bit BLAS and LAPACK
#
# Note that this works as long as BLAS and LAPACK are detected properly via
# pkg-config. By default we look for OpenBLAS, other libraries can be configured via
# `meson configure -Dblas=blas -Dlapack=lapack` (example to build with Netlib
# BLAS and LAPACK).
# For MKL and for auto-detecting one of multiple libs, we'll need a custom
# dependency in Meson (like is done for scalapack) - see
# https://github.com/mesonbuild/meson/issues/2835

blas_name = get_option('blas')
lapack_name = get_option('lapack')
allow_noblas = get_option('allow-noblas')

# This is currently injected directly into CFLAGS/CXXFLAGS for wheel builds
# (see cibuildwheel settings in pyproject.toml), but used by CI jobs already
blas_symbol_suffix = get_option('blas-symbol-suffix')

use_ilp64 = get_option('use-ilp64')
if use_ilp64
  blas_interface = ['interface: ilp64']
else
  blas_interface = ['interface: lp64']
endif

# pkg-config uses a lower-case name while CMake uses a capitalized name, so try
# that too to make the fallback detection with CMake work
blas_order = get_option('blas-order')
if blas_order == ['auto']
  blas_order = []
  if host_machine.system() == 'darwin'
    blas_order += 'accelerate'
  endif
  if host_machine.cpu_family() == 'x86_64'
    blas_order += 'mkl'
  endif
  blas_order += ['openblas', 'flexiblas', 'blis', 'blas']
endif
lapack_order = get_option('lapack-order')
if lapack_order == ['auto']
  lapack_order = []
  if host_machine.system() == 'darwin'
    lapack_order += 'accelerate'
  endif
  if host_machine.cpu_family() == 'x86_64'
    lapack_order += 'mkl'
  endif
  lapack_order += ['openblas', 'flexiblas', 'lapack']
endif

# MKL-specific options
_threading_opt = get_option('mkl-threading')
if _threading_opt == 'auto'
  # Switch default to iomp once conda-forge missing openmp.pc issue is fixed
  mkl_opts = ['threading: seq']
else
  mkl_opts = ['threading: ' + _threading_opt]
endif
blas_opts = {'mkl': mkl_opts}
mkl_version_req = '>=2023.0'  # see gh-24824
mkl_may_use_sdl = not use_ilp64 and _threading_opt in ['auto', 'iomp']

# Note that we can only use a BLAS which provides a CBLAS interface. So disable
# BLAS completely if CBLAS is not found.

# First try scipy-openblas, and if found don't look for cblas or lapack, we
# know what's inside the scipy-openblas wheels already.
if blas_name == 'openblas' or blas_name == 'auto'
  blas = dependency('scipy-openblas', required: false)
  if blas.found()
    blas = dependency('scipy-openblas', method: 'pkg-config', required: false)
  endif
  if blas.found()
    blas_name = 'scipy-openblas'
  endif
endif
if blas_name == 'auto'
  foreach _name : blas_order
    if _name == 'mkl'
      blas = dependency('mkl',
        modules: ['cblas'] + blas_interface + mkl_opts,
        required: false,  # may be required, but we need to emit a custom error message
        version: mkl_version_req,
      )
      # Insert a second try with MKL, because we may be rejecting older versions
      # or missing it because no pkg-config installed. If so, we need to retry
      # with MKL SDL, and drop the version constraint (this always worked).
      if not blas.found() and mkl_may_use_sdl
        blas = dependency('mkl', modules: ['cblas', 'sdl: true'], required: false)
      endif
    else
      if _name == 'flexiblas' and use_ilp64
        _name = 'flexiblas64'
      endif
      blas = dependency(_name, modules: ['cblas'] + blas_interface, required: false)
    endif
    if blas.found()
      break
    endif
  endforeach
else
  if blas_name == 'mkl'
    blas = dependency('mkl',
      modules: ['cblas'] + blas_interface + mkl_opts,
      required: false,
      version: mkl_version_req,
    )
    # Same deal as above - try again for MKL
    if not blas.found() and mkl_may_use_sdl
      blas = dependency('mkl', modules: ['cblas', 'sdl: true'], required: false)
    endif
  else
    blas = dependency(blas_name, modules: ['cblas'] + blas_interface, required: false)
  endif
endif

have_blas = blas.found()
if have_blas
  _args_blas = ['-DHAVE_CBLAS']  # note: used for C and C++ via `blas_dep` below
  if use_ilp64
    _args_blas += ['-DHAVE_BLAS_ILP64']
    if 'openblas' in blas.name()
      _args_blas += ['-DOPENBLAS_ILP64_NAMING_SCHEME']
    endif
  endif
  if blas_symbol_suffix == 'auto'
    if blas_name == 'scipy-openblas' and use_ilp64
      blas_symbol_suffix = '64_'
    else
      blas_symbol_suffix = blas.get_variable('symbol_suffix', default_value: '')
    endif
    message(
      '\n' +
      BLUE + '[INFO]' + RESET +
      f' BLAS symbol suffix: @blas_symbol_suffix@'
    )
  endif
  if blas_symbol_suffix != ''
    _args_blas += ['-DBLAS_SYMBOL_SUFFIX=' + blas_symbol_suffix]
  endif
  blas_dep = declare_dependency(
    dependencies: [blas],
    compile_args: _args_blas,
  )
else
  if allow_noblas
    blas_dep = []
  else
    error('No BLAS library detected! Install one, or use the ' + \
          '`allow-noblas` build option (note, this may be up to 100x slower ' + \
          'for some linear algebra operations).')
  endif
endif

if 'mkl' in blas.name() or blas.name() == 'accelerate' or blas_name == 'scipy-openblas'
  # For these libraries we know that they contain LAPACK, and it's desirable to
  # use that - no need to run the full detection twice.
  lapack = blas
else
  if lapack_name == 'auto'
    foreach _name : lapack_order
      lapack = dependency(_name, modules: ['lapack'] + blas_interface, required: false)
      if lapack.found()
        break
      endif
    endforeach
  else
    lapack = dependency(lapack_name, modules: ['lapack'] + blas_interface, required: false)
  endif
endif

have_lapack = lapack.found()
if not have_lapack and not allow_noblas
  error('No LAPACK library detected! Install one, or use the ' + \
        '`allow-noblas` build option (note, this may be up to 100x slower ' + \
        'for some linear algebra operations).')
else
  lapack_dep = declare_dependency(dependencies: [lapack, blas_dep])
endif

######################################################################
## Fortran Compiler Setup
######################################################################

# Adding at project level causes many spurious -lgfortran flags.
add_languages('fortran', native: false)
ff = meson.get_compiler('fortran')
if ff.get_id() == 'gcc'
  # -std=legacy is not supported by all Fortran compilers, but very useful with
  # gfortran since it avoids a ton of warnings that we don't care about.
  # Needs fixing in Meson, see https://github.com/mesonbuild/meson/issues/11633.
  add_project_arguments('-std=legacy', language: 'fortran')
endif

if ff.has_argument('-Wno-conversion')
  add_project_arguments(
    '-Wno-conversion',
    language: ['fortran'],
  )
endif

######################################################################
## Fortran Global compiler flags/options argument
######################################################################

# Fortran compiler options
# The default list of warnings to ignore from Fortran code. There is a lot of
# old, vendored code that is very bad and we want to compile it silently (at
# least with GCC and Clang)
# Fortran warning flags
_global_fortran_args = [
  # Define warning flags for Fortran compilation
  '-Wno-argument-mismatch',      # Suppress warnings about mismatched argument types in subroutine/function calls
  '-Wno-conversion',             # Suppress warnings about implicit type conversions
  '-Wno-intrinsic-shadow',       # Suppress warnings about shadowing intrinsic names
  '-Wno-maybe-uninitialized',    # Suppress warnings about variables that might be used uninitialized
  '-Wno-surprising',             # Suppress warnings about non-standard Fortran practices
  '-Wno-uninitialized',          # Suppress warnings about uninitialized variables
  '-Wno-unused-dummy-argument',  # Suppress warnings about dummy arguments that are unused
  '-Wno-unused-label',           # Suppress warnings about unused labels
  '-Wno-unused-variable',        # Suppress warnings about unused variables
  '-Wno-tabs',                   # Suppress warnings about tabs in the source code (often used in legacy code)
]
# Compiler options for Fortran
# # Apply fortran arguments if supported
# foreach arg : _global_fortran_args
#   if ff.has_argument(arg)
#     add_project_arguments(arg, language: 'fortran')
#   else
#     # Debug message for compiler IDs
#     message('fortran compiler (' + ff.get_id() + ') does not support argument: ' + arg)
#   endif
# endforeach
# fortran_ignore_warnings _global_fortran_args
_global_fortran_args = ff.get_supported_arguments(
  _global_fortran_args
)
add_project_arguments(
  _global_fortran_args, language: ['fortran'],
)

######################################################################
## C and C++ Compiler Setup
## -D : Define a macro, It's equivalent to putting `#define DEBUG` at the top of every source file.
## -d : Internal debugging options (rarely used by end users), Print all macros after preprocessing.
## -f : Enable/disable compiler feature flags, Codegen or safety behavior toggles.
##
## -fPIC	  : Feature	Enables position-independent code
## -dM	    : Debugging	Shows all macros after preprocessing
## -DDEBUG	: Macro	Defines DEBUG for #ifdef DEBUG
## -Wall	  : Warning	Turns on most compiler warnings
## -O2	    : Optimization	Enables safe, general optimizations
######################################################################
# Meson usually handles -fPIC automatically when building shared libraries
# '-fPIC'                         # Required for building position-independent shared libraries
# -fPIC: Generate position-independent code
# -funroll-loops: Unroll loops for performance (can be risky)

cc  = meson.get_compiler('c')
cpp = meson.get_compiler('cpp')

# C Compiler version checks
cc_version = cc.version()

# Detect which C and C++ compiler is being used
cc_id  = cc.get_id()
cpp_id = cpp.get_id() # Possible values: 'gcc', 'clang', 'msvc', etc.

# Check compiler is recent enough (see the SciPy Toolchain Roadmap for details)
if cc_id == 'gcc'
  if not cc_version.version_compare('>=9.1')
    error('scikit-plots requires GCC >= 9.1')
  endif
elif cc_id == 'clang' or cc_id == 'clang-cl'
  if not cc_version.version_compare('>=12.0')
    error('scikit-plots requires Clang >= 12.0')
  endif
elif cc_id == 'msvc'
  if not cc_version.version_compare('>=19.20')
    error('scikit-plots requires MSVC >= 19.20 (Visual Studio 2019 or newer)')
  endif
endif

######################################################################
## Compiler Feature Flags: C strict aliasing flags
######################################################################

# Add default compile flags for any compiler that supports them.
# Note that MSVC does not support strict aliasing at all, and neither do the
# Intel compilers on Windows, so the `-fno` flavor of the flag should be fine.
# -fno-strict-aliasing: Disable certain optimizations that assume pointer types don’t alias
add_project_arguments(
  cc.get_supported_arguments('-fno-strict-aliasing'),
  language : ['c'],
)

######################################################################
## Compiler Flags: Clang trapping math flags
######################################################################

# Clang defaults to a non-strict floating error point model, but we need strict
# behavior. `-ftrapping-math` is equivalent to `-ffp-exception-behavior=strict`.
# This flag is also required to prevent the activation of SIMD partial load workarounds.
# For further clarification, refer to gh-24461.
cc_id = cc.get_id()
if cc_id.startswith('clang')
  # Determine the compiler flags for trapping math exceptions.
  trapping_math = {
    'clang-cl': '/clang:-ftrapping-math',
  }.get(cc_id, '-ftrapping-math')
  # Check if the compiler supports the trapping math flag.
  if cc.has_argument(trapping_math)
    # TODO: Consider upgrading the vendored Meson to 1.3.0 to support the parameter `werror`
    # Detect whether the compiler actually supports strict handling of floating-point exceptions
    # by treating warnings as errors.
    if cc.compiles('int main() { return 0; }', args: [trapping_math, '-Werror'])
      trapping_math = [trapping_math, '-DNPY_HAVE_CLANG_FPSTRICT']
    else
      # Suppress warnings about unsupported floating-point optimization.
      trapping_math = [trapping_math, '-Wno-unsupported-floating-point-opt']
      # Inform the user about the workaround.
      message(
        '\n' +
        BLUE + '[INFO]' + RESET +
        ' Clang version does not strictly ' +
        'enforce floating-point exception handling. ' +
        'Performance may be impacted. Consider upgrading Clang.'
      )
    endif
    add_project_arguments(
      trapping_math,
      language: ['c', 'cpp']
    )
  endif
endif

######################################################################
## C and C++ Global compiler flags/options argument
######################################################################

# -dM: Dump all macros after preprocessing
# -dD: Dump only macros defined in the current file

# List of global arguments for C and C++
_global_args = [
  '-DDEBUG',                        # Define DEBUG macro for conditional debug printing or logging
  '-W',                             # Enable all warnings
  '-Werror=unused-variable',        # Treat unused variables as errors to enforce code quality
  '-Wno-cast-align',                # Suppress warnings if a pointer is cast to a type with different alignment
  '-Wno-cast-qual',                 # Suppress warnings if a pointer is cast to a type with different qualifiers
  '-Wno-conversion',                # Suppress warnings about type conversions
  '-Wno-double-promotion',          # Suppress warnings if a float is promoted to double
  '-Wno-error=unused-function',     # Suppress errors for unused functions
  '-Wno-float-equal',               # Suppress warnings if floating-point values are compared for equality
  '-Wno-format-truncation',         # Suppress warnings about format string truncations
  '-Wno-misleading-indentation',    # Suppress warnings about misleading indentation
  '-Wno-parentheses',               # Suppress warnings about unnecessary parentheses
  '-Wno-pointer-arith',             # Suppress warnings about pointer arithmetic
  '-Wno-redundant-decls',           # Suppress warnings about redundant declarations
  '-Wno-sequence-point',            # Suppress warnings about potential sequence point issues
  '-Wno-shadow',                    # Suppress warnings if a local variable shadows another variable
  '-Wno-sign-compare',              # Suppress warnings about comparisons between signed and unsigned integers
  '-Wno-switch',                    # Suppress warnings about switch statement cases that are not handled
  '-Wno-undef',                     # Suppress warnings if an undefined macro is used
  '-Wno-unused-but-set-parameter',  # Suppress warnings about parameters that are set but not used
  '-Wno-unused-function',           # Suppress warnings about unused functions
  '-Wno-unused-label',              # Suppress warnings about unused labels
  '-Wno-unused-parameter',          # Suppress warnings about unused parameters
  '-Wno-unused-result',             # Suppress warnings about unused results
  '-Wno-unused-variable',           # Suppress warnings about unused variables
  '-Wno-write-strings',             # Treat string literals as `const char[]`
  '-Wno-discarded-qualifiers',      # to suppress warnings about discarded qualifiers (like const, volatile, etc.).
]
# Additional arguments for C
_global_c_args = cc.get_supported_arguments(
  _global_args + [
    '-Wno-implicit-function-declaration',  # Suppress warnings about implicit function declarations
  ]
)
# Additional arguments for C++
_global_cpp_args = cpp.get_supported_arguments(
  # GCC/Clang flags
  _global_args + [
    # '-std=c++17',              # WARNING: Consider using the built-in option for language standard version instead of using "-std=c++17".
    '-Wno-class-memaccess',      # Suppress warnings about accessing class members inappropriately
    '-Wno-int-in-bool-context',  # Suppress warnings about int used in boolean context
    '-Wno-non-virtual-dtor',     # Suppress warnings about non-virtual destructors
    # invalid in MSVC (cl) as they are specific to GCC/Clang
    '-Wno-cpp',                  # Suppress warnings about C++ preprocessor directives
    '-Wno-pedantic',             # Suppress strict ISO C++ compliance warnings
    '-Wno-terminate',            # Suppress warnings about code that might terminate unexpectedly
  ]
)
if host_machine.system() == 'linux' or host_machine.system() == 'darwin'
  add_project_link_arguments('-pthread', language: ['c', 'cpp'])  # Add pthread support for POSIX systems
endif

# Enable multithreading if std::thread is supported
if (cpp.has_function('std::thread') or
    cpp.compiles('#include <thread>\nint main() { std::thread t; return 0; }', name: 'std::thread support'))
  # Enable multithreading with STL parallel execution policies
  _global_cpp_args += ['-DNUMCPP_USE_MULTITHREAD']
endif

# Apply C arguments if supported
foreach arg : _global_c_args
  if cc.has_argument(arg)
    add_project_arguments(arg, language: 'c')
  else
    # Debug message for compiler IDs
    message(
      '\n' +
      BLUE + '[INFO]' + RESET +
      ' C compiler (' + cc_id + ') does not support argument: ' + arg
    )
  endif
endforeach

# Apply C++ arguments if supported
foreach arg : _global_cpp_args
  if cpp.has_argument(arg)
    add_project_arguments(arg, language: 'cpp')
  else
    # Debug message for compiler IDs
    message(
      '\n' +
      BLUE + '[INFO]' + RESET +
      ' C++ compiler (' + cpp_id + ') does not support argument: ' + arg
    )
  endif
endforeach

######################################################################
## C and C++ Math Library functions, symbols
######################################################################

# We need -lm for all C code (assuming it uses math functions, which is safe to
# assume for scikit-image). For C++ it isn't needed, because libstdc++/libc++ is
# guaranteed to depend on it. For Fortran code, Meson already adds `-lm`.
dep_math = cc.find_library('m', required : false)
if dep_math.found()
  add_project_link_arguments(
    ['-lm'], language : ['c'],
  )
endif

# Intel compilers default to fast-math, so disable it if we detect Intel
# compilers. A word of warning: this may not work with the conda-forge
# compilers, because those have the annoying habit of including lots of flags
# that are gcc-specific in CFLAGS/CXXFLAGS/FFLAGS, which throws off the
# detection logic below. You have to remove the wrong flags (only `-isystem`
# is actually needed, everything else shouldn't be there).
_intel_cflags = []
_intel_fflags = []
if cc.get_id() in ['intel', 'intel-llvm']
  _intel_cflags += cc.get_supported_arguments('-fp-model=strict')
elif cc.get_id() in ['intel-cl', 'intel-llvm-cl']
  _intel_cflags += cc.get_supported_arguments('/fp:strict')
endif
if ff.get_id() in ['intel', 'intel-llvm']
  _intel_fflags = ff.get_supported_arguments('-fp-model=strict')
  minus0_arg = ['-assume', 'minus0']
  if ff.has_multi_arguments(minus0_arg)
    _intel_fflags += minus0_arg
  endif
elif ff.get_id() in ['intel-cl', 'intel-llvm-cl']
  # Intel Fortran on Windows does things differently, so deal with that
  # (also specify dynamic linking and the right name mangling)
  _intel_fflags = ff.get_supported_arguments(
    '/fp:strict', '/MD', '/names:lowercase', '/assume:underscore',
    '/assume:minus0'
  )
endif
add_project_arguments(_intel_cflags, language: ['c', 'cpp'])
add_project_arguments(_intel_fflags, language: 'fortran')

######################################################################
## C and C++ Symbol Visibility
######################################################################

# Hide symbols when building on Linux with GCC. For Python extension modules,
# we only need `PyInit_*` to be public; anything else may cause problems.
# So we use a linker script to avoid exporting those symbols (this is in addition
# to Meson using `-fvisibility=hidden` for C and `-fvisibility-inlines-hidden` for C++ code).
# See gh-15996 for details.

_linker_script = meson.project_source_root() / 'scikitplot/_build_utils/link-version-pyinit.map'
version_link_args = [
  '-Wl,--version-script=' + _linker_script,
]

# Note that FreeBSD only accepts version scripts when -shared is passed,
# hence we need to pass that to `cc.links` explicitly (the flag is already present
# for `extension_module` invocations).
if not cc.links('', name: '-Wl,--version-script', args: ['-shared'] + version_link_args)
  version_link_args = []
endif

######################################################################
## C 32-bit platforms when atomic operations
######################################################################

# Determine whether it is necessary to link libatomic with gcc. This
# could be the case on 32-bit platforms when atomic operations are used
# on 64-bit types or on RISC-V using 8-bit atomics, so we explicitly
# check for both 64 bit and 8 bit operations.  The check is adapted from
# SciPy, who copied it from Mesa.
null_dep = dependency('', required : false)
atomic_dep = null_dep
code_non_lockfree = '''
  #include <stdint.h>
  int main() {
   struct {
     void *p;
     uint8_t u8v;
   } x;
   x.p = NULL;
   x.u8v = 0;
   uint8_t res = __atomic_load_n(x.u8v, __ATOMIC_SEQ_CST);
   __atomic_store_n(x.u8v, 1, ATOMIC_SEQ_CST);
   void *p = __atomic_load_n(x.p, __ATOMIC_SEQ_CST);
   __atomic_store_n((void **)x.p, NULL, __ATOMIC_SEQ_CST)
   return 0;
   }
'''
if cc.get_id() != 'msvc'
  if not cc.links(
      code_non_lockfree,
      name : 'Check atomic builtins without -latomic'
    )
    atomic_dep = cc.find_library('atomic', required: false)
    if atomic_dep.found()
      # We're not sure that with `-latomic` things will work for all compilers,
      # so verify and only keep libatomic as a dependency if this works. It is
      # possible the build will fail later otherwise - unclear under what
      # circumstances (compilers, runtimes, etc.) exactly and this may need to
      # be extended when support is added for new CPUs
      if not cc.links(
          code_non_lockfree,
          dependencies: atomic_dep,
          name : 'Check atomic builtins with -latomic'
        )
        atomic_dep = null_dep
      endif
    endif
  endif
endif

######################################################################
## Platform OS detection
######################################################################

# Platform detection
is_windows = host_machine.system() == 'windows'
is_mingw = is_windows and cc.get_id() == 'gcc'
# is_mingw = is_windows and cc.get_define('__MINGW32__') != ''

if is_mingw and ff.get_id() != 'gcc'
  error(
    'If you are using GCC on Windows, you must also use GFortran! ' +
    'Detected: @0@'.format(ff.get_id())
  )
endif

######################################################################
## macOS 14
######################################################################

macOS13_3_or_later = false
if host_machine.system() == 'darwin'
  r = run_command('xcrun', '-sdk', 'macosx', '--show-sdk-version', check: true)
  sdkVersion = r.stdout().strip()

  macOS13_3_or_later = sdkVersion.version_compare('>=13.3')
endif

if host_machine.system() == 'darwin'
  # Check if the compiler supports the '-Wl,-ld_classic' argument (new linker in macOS 14)
  if cc.has_link_argument('-Wl,-ld_classic')
    # New linker introduced in macOS 14 not working yet with at least OpenBLAS in Spack,
    # see gh-24964 (and linked scipy issue from there).
    add_project_link_arguments('-Wl,-ld_classic', language : ['c', 'cpp', 'fortran'])
  endif
  # Check if the compiler supports the '-Wl,-dead_strip' argument (linker option to strip unused symbols)
  if cc.has_link_argument('-Wl,-dead_strip')
    # Allow linker to strip unused symbols
    add_project_link_arguments('-Wl,-dead_strip', language : ['c', 'cpp', 'fortran'])
  endif
endif

######################################################################
## python
######################################################################

# Import the Python module from Meson to interact with the Python installation
# https://mesonbuild.com/Python-module.html
mod_py = import('python')
# NOTE: with Meson >=0.64.0 we can add `pure: false` here and remove that line
# everywhere else, see https://github.com/mesonbuild/meson/pull/10783.
# py = find_program('python3', 'python', required: true)  # Find Python cross-platform
py = mod_py.find_installation(pure: false)  # Find system Python

# Get the Python Dependencies
dep_py = py.dependency()

# Emit a warning for 32-bit Python installs on Windows; users are getting
# unexpected from-source builds there because we no longer provide wheels.
if is_windows and py.has_variable('EXT_SUFFIX')
  if py.get_variable('EXT_SUFFIX').contains('win32')
    warning(
      'You are building from source on a 32-bit Python install. ' +
      'scikitplot does not provide 32-bit wheels; install 64-bit Python ' +
      'if you are having issues!'
    )
  endif
endif

######################################################################
## python headers 'Python.h'
######################################################################

if not cc.has_header('Python.h', dependencies: dep_py)
  error('Cannot compile `Python.h`. ' +
    'Perhaps you need to install python-dev|python-devel')
endif

# # Attempt to get the Python include directory
# _py_inc_dir = meson.get_external_property(
#   'python-include-dir',
#   'not-given'
# )
# if _py_inc_dir == 'not-given'
#   _py_inc_dir = run_command(
#     py,
#     [
#       '-c',
#       '''\
# import sysconfig
# print(sysconfig.get_path("include"))
# '''
#     ],
#     check: true
#   ).stdout().strip()
# endif
# # Use the include directory in your build setup
# inc_dir_py = include_directories(_py_inc_dir)

# Print the include directory
# message('python include dir: @0@'.format(_py_inc_dir))

######################################################################
## pybind11 is a lightweight header-only library
## that exposes C++11 types in Python and vice versa
## https://github.com/pybind/pybind11
## https://pybind11.readthedocs.io/_/downloads/en/latest/pdf/
## pybind11/pybind11.h includes Python.h,
## as such it must be the first file included in any source file
## or header for the same reasons as 'Python.h'.
######################################################################

# python3 -m pybind11 --includes
# pybind11 — Seamless operability between C++11 and Python
dep_pybind11 = dependency('pybind11', version: '>=2.13.0')

######################################################################
## pythran
######################################################################

# Search for pythran
pythran = find_program(
  'pythran',
  native: true,
  version: '>=0.14.0',
  required: get_option('pythran').enabled(),
)
if get_option('pythran').enabled()
  # xsimd is unvendored from pythran by conda-forge, and due to a compiler
  # activation bug the default <prefix>/include/ may not be visible (see
  # gh-15698). Hence look for xsimd explicitly.
  dep_xsimd = dependency('xsimd', required: false)
endif

######################################################################
## pythran args
######################################################################

# Pythran build flags
if get_option('pythran').enabled()
  # Base Pythran-specific flags
  _pythran_base_args = [
    '-DENABLE_PYTHON_MODULE',  # Enable Python module support
    '-D__PYTHRAN__=3',         # Define Pythran version
    '-DPYTHRAN_BLAS_NONE',     # Disable BLAS
  ]
  # Pythran base and C++ warning flags
  # _global_pythran_cpp_args = _pythran_base_args + _global_cpp_args
  # add_project_arguments(
  #   _global_pythran_cpp_args,
  #   language: ['pythran'],
  # )
endif

######################################################################
## pythran include dir
######################################################################

# Pythran include directory
if get_option('pythran').enabled()
  _pythran_inc_dir = meson.get_external_property(
    'pythran-include-dir',
    'not-given'
  )
  if incdir_pythran == 'not-given'
    # If not specified, try to query Pythran from the build python
    _pythran_inc_dir = run_command(py,
      [
        '-c',
      '''\
import os; os.chdir('..')
import pythran
print(os.path.dirname(pythran.__file__))
'''
      ],
      check: true
    ).stdout().strip()
  endif
  inc_dir_pythran = include_directories(_pythran_inc_dir)

  message(
  '\n' +
  BLUE + '[INFO]' + RESET +
  ' pythran include dir: @0@'.format(_pythran_inc_dir)
  )
endif

######################################################################
## cython
######################################################################

# Find the Cython program, which is needed to compile .pyx files to .c or .cpp files
cy = meson.get_compiler('cython')

# generator() doesn't accept compilers, only found programs - cast it as cli_cython.
cli_cython = find_program(cy.cmd_array()[0])

# Scipy variant of Cython command
# cli_cython = find_program('scikitplot/_build_utils/cythoner.py')

######################################################################
## Common Cython arguments
######################################################################

# cython_args = ['-3', '--fast-fail', '--output-file', '@OUTPUT@', '--include-dir', '@BUILD_ROOT@', '@INPUT@']

# Define the arguments for the Cython command. These arguments will be passed
# to the Cython compiler when generating the C source files.
cython_c_args = [
  # '-O2',                                    # Optimization level
  # '-X boundscheck=' + boundscheck,          # Control bounds checking (True/False)
  '-X language_level=3',                      # Ensure Cython targets Python3 like '-3'
  # Prevents using negative indexing, which can provide a speedup for array handling.
  '-X wraparound=False',                      # Disable negative indexing (wraparound)
  # Skips checking for uninitialized variables, improving performance at the cost of safety.
  '-X initializedcheck=False',                # Disable check for uninitialized variables
  # Skips checking for None values, improving performance when you're sure that variables won’t be None.
  '-X nonecheck=False',                       # Disable None checks
  # Enables C-style division (ignores Python division safety), improving performance.
  '-X cdivision=True',                        # Enable C division
  # Disables profiling support, which improves speed if profiling isn’t needed.
  '-X profile=False',                         # Disable profiling
  '--fast-fail',                              # Halt on first error during compilation
  # Specifies the include directory where Cython can find the necessary headers.
  # Needed for cython imports across subpackages, e.g. cluster pyx that
  # cimports metrics pxd
  # '--include-dir', '@BUILD_ROOT@',          # Placeholder for Meson to replace later
  '--include-dir', meson.global_build_root(), # Directly resolves to the build root path
  # '--output-file', '@OUTPUT@',              # Specify output file for generated C code
  # '@INPUT@',                                # Input file placeholder managed by Meson
]
# If the Cython version is 3.1.0 or newer, add the option for free threading compatibility
if cy.version().version_compare('>=3.1.0')
  cython_c_args += ['-Xfreethreading_compatible=True']
endif
# Define additional arguments specifically for generating C++ files with Cython
cython_cpp_args = cython_c_args + ['--cplus']  # The '--cplus' flag tells Cython to generate C++ code

######################################################################
## Cython generator/compiler
## pyx -> c, pyx -> cpp generators, depending on copied pxd files and init
## https://mesonbuild.com/Reference-manual_functions.html#generator
## https://mesonbuild.com/Reference-manual_functions.html#custom_target
######################################################################

_gen_cython_args = [
  # '--include-dir', '@BUILD_ROOT@',      # Placeholder for Meson to replace later
  '--output-file', '@OUTPUT@',          # Specify output file for generated C code
  '@INPUT@',                            # Input file placeholder managed by Meson
]

# Create a generator for converting .pyx files to .c files using the defined Cython arguments
gen_cython_c = generator(
  cli_cython,
  arguments : _gen_cython_args + cython_c_args,  # Use the previously defined arguments
  output : '@BASENAME@.c',             # The output will be a .c file with the same base name as the input .pyx file
  # depends : _cython_tree             # Optional: Specify dependencies like .pxd files, if any
)
# Create a generator for converting .pyx files to .cpp files (C++ code) using Cython arguments
gen_cython_cpp = generator(
  cli_cython,
  arguments : _gen_cython_args + cython_cpp_args,  # Use the C++ specific arguments
  output : '@BASENAME@.cpp',         # The output will be a .cpp file with the same base name as the input .pyx file
  # depends : [_cython_tree]         # Optional: Specify dependencies like .pxd files, if any
)

# Conditional generation with Pythran, a tool that accelerates Python code.
# This block is only executed if the 'use_pythran' option is enabled.
if get_option('pythran').enabled()
  # Define a generator for Pythran to convert Python files into C++ code
  # Note: The arguments need to be updated when Pythran supports running without the GIL (Global Interpreter Lock)
  pythran_gen = generator(
    pythran,
    arguments : ['-E', '@INPUT@', '-o', '@OUTPUT@'],  # '-E' expands macros, '@INPUT@' is the input file, and '@OUTPUT@' is the output
    output : '@BASENAME@.cpp',                        # Output will be a .cpp file
  )
endif

######################################################################
## Set common build flags for C and C++ code
######################################################################

# Adapted from Scipy. mingw is untested and not officially supported. If you
# ever bump into issues when trying to compile for mingw, please open an issue
# in the scikit-learn issue tracker
cython_c_flags = [
  '-DCYTHON_CCOMPLEX=0',  # see gh-18975 for why we need this
]

if is_mingw
  is_mingw_built_python = run_command(
    py, ['-c', 'import sysconfig; print(sysconfig.get_platform())'],
    check: true
  ).stdout().strip().startswith('mingw')
  if not is_mingw_built_python
    # For mingw-w64, link statically against the UCRT.
    _gcc_link_args = ['-lucrt', '-static']
    add_project_link_arguments(_gcc_link_args, language: ['c', 'cpp', 'fortran'])
    # Force gcc to float64 long doubles for compatibility with MSVC
    # builds, for C only.
    add_project_arguments('-mlong-double-64', language: 'c')
  endif
  # Make fprintf("%zd") work (see https://github.com/rgommers/scipy/issues/118)
  add_project_arguments('-D__USE_MINGW_ANSI_STDIO=1', language: ['c', 'cpp'])
endif
if is_mingw
  ###############################################################
  # Manual add of MS_WIN64 macro when not using MSVC.
  # https://bugs.python.org/issue28267
  bitness = run_command(
    '_build_utils/gcc_build_bitness.py',
    check: true
  ).stdout().strip()
  if bitness == '64'
    add_project_arguments(
      '-DMS_WIN64',
      language: ['c', 'cpp'],
    )
  endif
  ###############################################################
  # Silence warnings emitted by PyOS_snprintf for (%zd), see
  # https://github.com/rgommers/scipy/issues/118.
  # Use as c_args for extensions containing Cython code
  cython_c_flags += [
    '-Wno-format-extra-args',
    '-Wno-format',
  ]
  # Flag needed to work around BLAS and LAPACK Gfortran dependence on
  # undocumented C feature when passing single character string arguments. See:
  #   https://gcc.gnu.org/bugzilla/show_bug.cgi?id=90329
  #   https://github.com/wch/r-source/blob/838f9d5a7be08f2a8c08e47bcd28756f5d0aac90/src/gnuwin32/MkRules.rules#L121
  add_project_arguments(
    '-fno-optimize-sibling-calls',
    language: ['fortran']
  )
endif

# Deal with M_PI & friends; add `use_math_defines` to c_args or cpp_args
# Cython doesn't always get this right itself (see, e.g., gh-16800), so
# explicitly add the define as a compiler flag for Cython-generated code.
if is_windows
  use_math_defines = [
    '-D_USE_MATH_DEFINES',
  ]
else
  use_math_defines = []
endif

# Define C and C++ specific arguments
cython_c_flags += [use_math_defines]


# Adapted from Numpy.
# Same as NPY_CXX_FLAGS (TODO: extend for what ccompiler_opt adds)
cython_cpp_flags = cython_c_flags + [
  '-D__STDC_VERSION__=0',  # for compatibility with C headers
]
# if cc.get_argument_syntax() != 'msvc'
#   cython_cpp_flags += [
#     '-fno-exceptions',  # no exception support
#     '-fno-rtti',        # no runtime type information
#   ]
# endif

######################################################################
## Cross-compilation include dir
######################################################################

# When cross-compiling scikitplots, the compiler needs access to NumPy and Pythran
# headers for the host platform (where the package will actually run). These
# headers may be incompatible with any corresponding headers that might be
# installed on the build system (where the compilation is performed). To make
# sure that the compiler finds the right headers, paths can be configured in
# the 'properties' section of a Meson cross file:
#
#   [properties]
#   numpy-include-dir = '/path/to/host/numpy/includes'
#   pythran-include-dir = '/path/to/host/pythran/includes'
#
# If a cross file is not provided or does not specify either of these
# properties, fall back to running Python on the build system to query NumPy or
# Pythran directly for the appropriate paths. This will detect appropriate
# paths for native builds. (This might even work for certain build/host cross
# combinations, but don't rely on that.)
#
# For more information about cross compilation in Meson, including a definition
# of "build" and "host" in this context, refer to
#
#  https://mesonbuild.com/Cross-compilation.html

######################################################################
## dependency 'threads'
######################################################################

dep_thread = dependency('threads', required: false)

######################################################################
## Fs-module
## https://mesonbuild.com/Fs-module.html
######################################################################

# Copy the main __init__.py|pxd files to the build dir (needed for Cython)
fs = import('fs')

######################################################################
## dependency 'numpy'
######################################################################

min_numpy_version = '1.25.2'  # keep in sync with pyproject.toml

# Uses the `numpy-config` executable (or a user's numpy.pc pkg-config file).
# Will work for numpy>=2.0, hence not required (it'll be a while until 2.0 is
# our minimum supported version). Using this now to be able to detect the
# version easily for >=2.0.
_dep_np = dependency('numpy', required: false)
f2py_freethreading_arg = []
if _dep_np.found()
  if _dep_np.version().version_compare('>=2.1.0')
    f2py_freethreading_arg = ['--free-threading']
  endif
endif

######################################################################
## dependency 'numpy' include dir
######################################################################

# NumPy include directory - needed in all submodules
# The chdir is needed because within numpy there's an `import signal`
# statement, and we don't want that to pick up scipy's signal module rather
# than the stdlib module. The try-except is needed because when things are
# split across drives on Windows, there is no relative path and an exception
# gets raised. There may be other such cases, so add a catch-all and switch to
# an absolute path. Relative paths are needed when for example a virtualenv is
# placed inside the source tree; Meson rejects absolute paths to places inside
# the source tree.
# For cross-compilation it is often not possible to run the Python interpreter
# in order to retrieve numpy's include directory. It can be specified in the
# cross file instead:
#   [properties]
#   numpy-include-dir = '/abspath/to/host-pythons/site-packages/numpy/core/include'
#
# This uses the path as is, and avoids running the interpreter.
_np_inc_dir = meson.get_external_property(
  'numpy-include-dir',
  'not-given',
)
if _np_inc_dir == 'not-given'
  _np_inc_dir = run_command(py,
    ['-c', '''\
import os
import numpy as np
try:
  # get relpath path from absolute path
  os.chdir(os.path.join(".", "tools"))
  _np_inc_dir = os.path.relpath(np.get_include())
  if not os.path.exists(_np_inc_dir):
    raise FileNotFoundError('')  # dont print
except Exception as e:
  # use absolute path
  _np_inc_dir = np.get_include()
print(_np_inc_dir)''' ],
    check: true,
  ).stdout().strip()

  # We do need an absolute path to feed to `cc.find_library` below
  _np_inc_dir_abs = run_command(py,
    ['-c', 'import numpy; print(numpy.get_include())'],
    check: true,
  ).stdout().strip()
else
  _np_inc_dir_abs = _np_inc_dir
endif

message(
  '\n' +
  BLUE + '[INFO]' + RESET +
  ' numpy include dir    : @0@'.format(_np_inc_dir) +
  '\n' +
  BLUE + '[INFO]' + RESET +
  ' numpy include dir abs: @0@'.format(_np_inc_dir_abs)
)
# Use the include directory in your build setup
# Specify Include directories where your headers are located
# include_directories(header) -> static_library(mix), library(mix), declare_dependency(mix)
inc_dir_np = include_directories(_np_inc_dir)

# Don't use the deprecated NumPy C API. Define this to a fixed version instead of
# NPY_API_VERSION in order not to break compilation for released SciPy versions
# when NumPy introduces a new deprecation.
_global_np_args = [
  '-DNPY_NO_DEPRECATED_API=NPY_1_9_API_VERSION',
]
# Get the Numpy Dependencies
dep_np = declare_dependency(
  dependencies: [],
  include_directories: inc_dir_np,
  compile_args: _global_np_args,
)

######################################################################
## 'fortran' include dir
######################################################################

# full_path = join_paths(inc_path, 'subdir')  # ✅ correct
_f2py_inc_dir = _np_inc_dir / '..' / '..' / 'f2py' / 'src'
inc_dir_f2py = include_directories(_f2py_inc_dir)
fortranobject_c = _f2py_inc_dir / 'fortranobject.c'

if not fs.exists(fortranobject_c)
  warning(
    '\n' +
    YELLOW + '[WARNING]' + RESET +
    'Missing required file: ' + fortranobject_c + '\n' +
    'Make sure NumPy is installed from source with f2py support. Try:\n' +
    '  pip install numpy --no-binary :all:\n' +
    'Also ensure gfortran is installed.'
  )
  fortranobject_c = meson.project_source_root() / 'scikitplot/cexternals/_f2py/src/fortranobject.c'
endif

npymath_path = _np_inc_dir_abs / '..' / 'lib'
npymath_lib = cc.find_library('npymath', dirs: npymath_path)

######################################################################
## dependency 'fortran'
######################################################################

# Share this object across multiple modules.
fortranobject_lib = static_library('_fortranobject',
  fortranobject_c,
  c_args: _global_np_args,
  dependencies: dep_py,
  include_directories: [inc_dir_np, inc_dir_f2py],  # nested accepts
  gnu_symbol_visibility: 'hidden',
)
fortranobject_dep = declare_dependency(
  link_with: fortranobject_lib,
  include_directories: [inc_dir_np, inc_dir_f2py],  # nested accepts
)


######################################################################
## Generate file 'config/scikitplot_config.h'
## https://mesonbuild.com/Reference-manual_functions.html#configure_file
## https://github.com/scipy/scipy/blob/main/scipy/meson.build#L153
######################################################################

# Define configure_file
cdata = configuration_data()

# Test variable attribute to use for thread-local storage;
# Adapted from `numpy/_core/meson.build`.
check_tls_attrs = [
  ['thread_local', 'HAVE_THREAD_LOCAL'],    # C23
  ['_Thread_local', 'HAVE__THREAD_LOCAL'],  # C11/C17
  ['__thread', 'HAVE__THREAD'],
]
if is_windows and not is_mingw
  check_tls_attrs += ['__declspec(thread)', 'HAVE___DECLSPEC_THREAD_']
endif

f2py_tls_define = ''
foreach tls_attrs: check_tls_attrs
  attr = tls_attrs[0]
  code = f'''
    #pragma GCC diagnostic error "-Wattributes"
    #pragma clang diagnostic error "-Wattributes"

    int @attr@ foo;
  '''
  code += '''
    int
    main()
    {
      return 0;
    }
  '''
  if cc.compiles(code, name: tls_attrs[0])
    cdata.set10(tls_attrs[1], true)
    f2py_tls_define = tls_attrs[0]
  endif
endforeach

######################################################################
## 'fortran' _f2py_c_args
######################################################################

_f2py_c_args = [
  f'-DF2PY_THREAD_LOCAL_DECL=@f2py_tls_define@'
]
fortranobject_dep = declare_dependency(
  dependencies: fortranobject_dep,
  compile_args: _f2py_c_args,
)

######################################################################
## f2py
######################################################################

f2py = find_program('f2py', required: false)
if f2py.found()
  # It should be quite rare for the `f2py` executable to not be the one from
  # `numpy` installed in the Python env we are building for (unless we are
  # cross-compiling). If it is from a different env, that is still fine as long
  # as it's not too old. We are only using f2py as a code generator, and the
  # output is not dependent on platform or Python version (see gh-20612 for more
  # details).
  # This should be robust enough. If not, we can make this more complex, using
  # a fallback to `python -m f2py` rather than erroring out.
  #
  # f2py_version = run_command([f2py, '-v'], check: true).stdout().strip()
  # if f2py_version.version_compare('<'+min_numpy_version)
  #   error(f'Found f2py executable is too old: @f2py_version@')
  # endif
else
    warning(
      '\n' +
      YELLOW + '[WARNING]' + RESET +
      'Skipping f2py generation — f2py not available in this environment.'
    )
endif

######################################################################
## f2py_gen
######################################################################

generate_f2pymod = find_program('tools/f2py/generate_f2pymod.py')

# Note: this generator cannot handle:
# 1. `.pyf.src` files, because `@BASENAME@` will still include .pyf
# 2. targets with #include's (due to no `depend_files` - see feature request
#    at meson#8295)
f2py_gen = generator(generate_f2pymod,
  arguments : ['@INPUT@', '-o', '@BUILD_DIR@'] + f2py_freethreading_arg,
  output : ['_@BASENAME@module.c', '_@BASENAME@-f2pywrappers.f'],
)

######################################################################
## py tempita
######################################################################

# Usage: custom_target(command: [py, cli_tempita, '@INPUT@', '-o', '@OUTDIR@'],
# Usage: custom_target(command: [cli_tempita, '@INPUT@', '-o', '@OUTPUT@'],
cli_tempita = find_program('scikitplot/_build_utils/tempita.py')

# Usage: tempita_gen.process('__config__.py.in')
# Used for templated py/C/Cpp/pyx/pxd code
gen_tempita = generator(cli_tempita,
  arguments : ['@INPUT@', '-o', '@OUTPUT@'],
  output : '@BASENAME@',
)

######################################################################
## py copier
######################################################################

## If 'cp' is not found, try executing Python script directly but it not fully compatibility
# cli_copier = find_program(['cp', 'scikitplot/_build_utils/copyfiles.py'], required: false)

######################################################################
## Installation tags
## https://mesonbuild.com/Installing.html#installing
## https://mesonbuild.com/Installing.html#installation-tags
##
## It is possible to install only a subset of the installable files using
## meson install --tags tag1,tag2 command line. When --tags is specified,
## only files that have been tagged with one of the tags are going to be installed.
######################################################################

######################################################################
## Copy all the .py files  like [tool.setuptools.package-data]
## install_data() copies single files.
## install_subdir() copies directories recursively.
## https://mesonbuild.com/Reference-manual_functions.html#install_subdir
## https://mesonbuild.com/Installing.html#installing
######################################################################

# Install the main `scikitplot` package without any `tests` folders
# Copy all the .py files to the install dir, rather than using
# py.install_sources and needing to list them explicitly one by one
install_subdir(
  'scikitplot',
  install_dir: py.get_install_dir(),  # Folder relative to site-packages to install to
  install_tag: 'python-runtime',      # Tag to help categorize the install
  exclude_directories: [              # Exclude from installation, but it doesn't work as expected
    'js',                             # Excludes the 'tests' directory
  ],
)
# Optionally add a message to confirm the installation
message(
  '\n' +
  GREEN + '[SUCCESS]' + RESET +
  ' scikitplot files installed successfully: ' +
  '@0@'.format(py.get_install_dir())
)

######################################################################
## Next
######################################################################

# Not Need anymore we copying all submodules before runtime from 'third_party'
# subdir('third_party')
subdir('scikitplot')
