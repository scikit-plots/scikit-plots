# cython: wraparound=False, nonecheck=False, boundscheck=False, cdivision=True, language_level=3, binding=True, embedsignature=True
# distutils: language = c++
# distutils: extra_compile_args = -std=c++14 -O3 -march=native -DNDEBUG -pthread -DANNOYLIB_MULTITHREADED_BUILD
# distutils: extra_link_args = -std=c++14
#
# cython annoylib.pyx --cplus
# g++ -std=c++14 -O3 -fPIC -DANNOYLIB_MULTITHREADED_BUILD -pthread \
#     -c annoylib.cpp -o annoylib.o
# g++ -shared annoylib.o -lpthread -o annoylib.so

"""
Cython Declaration File for Annoy C++ Library.

This file declares the C++ interfaces from annoylib.h for use in Cython.

Design Principles:

1. **Explicit Type Declarations**: All C++ types explicitly declared
2. **Safe Memory Management**: Proper pointer handling with nogil where safe
3. **Error Propagation**: char** error pattern for C++ exceptions
4. **Platform Compatibility**: Windows, Linux, macOS support

Type System:

* S (index type): int32_t (item/node identifiers)
* T (data type): float (embedding values)
* Distance: float (distance values, potentially clipped for Hamming)
* Random: uint64_t (seed type)

Notes
-----
* All methods that can throw C++ exceptions use char** error parameter
* nogil blocks are used only for pure computational methods
* GIL is held during Python object manipulation

ðŸ§  What .pxd Is Allowed To Contain - C-level declaration headers
Allowed:
    - cdef enum
    - cdef struct
    - cdef cppclass
    - cdef extern
    - cdef inline functions that are pure C-level
Not allowed:
    - Returning str
    - Raising ValueError
    - Creating Python objects
    - Runtime Python logic

Code Type                    Where It Goes     Why
Python dict {}               .pyx              Runtime Python objects
Function raising exception   .pyx              Python runtime feature
Pure C cdef inline           .pxd              No Python objects/exceptions
cdef extern                  .pxd              C/C++ declarations
cdef enum/struct             .pxd              Type declarations

References:
    - annoylib.h: C++ template implementation
    - https://cython-guidelines.readthedocs.io/en/latest/articles/lie.html
    - Cython fused types: https://cython.readthedocs.io/en/latest/src/userguide/fusedtypes.html
    - https://cythoncython.readthedocs.io/en/latest/src/userguide/external_C_code.html#c-api-declarations
    - https://cythoncython.readthedocs.io/en/latest/src/userguide/external_C_code.html#public-declarations
    - https://cythoncython.readthedocs.io/en/latest/src/userguide/sharing_declarations.html#sharing-declarations
    - https://cythoncython.readthedocs.io/en/latest/src/userguide/external_C_code.html#struct-union-enum-styles
    - https://cythoncython.readthedocs.io/en/latest/src/userguide/language_basics.html?highlight=cpdef%20enum#type-casting
    - https://cythoncython.readthedocs.io/en/latest/src/userguide/external_C_code.html#releasing-the-gil
    - https://cythoncython.readthedocs.io/en/latest/src/userguide/external_C_code.html#acquiring-the-gil
    - https://cythoncython.readthedocs.io/en/latest/src/userguide/external_C_code.html#declaring-a-function-as-callable-without-the-gil
    - https://cython.readthedocs.io/en/latest/src/userguide/external_C_code.html#resolving-naming-conflicts-c-name-specifications
    - https://cython.readthedocs.io/en/latest/src/userguide/external_C_code.html#including-verbatim-c-code
    - https://docs.cython.org/en/latest/src/userguide/wrapping_CPlusPlus.html#templates
    - https://docs.cython.org/en/latest/src/userguide/extension_types.html#attribute-name-matching-and-aliasing
"""

from libc.stdint cimport int32_t, uint32_t, uint64_t, uint8_t
from libcpp cimport bool as cpp_bool
from libcpp.string cimport string as cpp_string
from libcpp.vector cimport vector
from libcpp.unordered_map cimport unordered_map


# ==============================================================================
# KISS Random Number Generator Interface
# ==============================================================================

cdef extern from "kissrandom.h" namespace "Annoy":
    """
    KISS random number generator declarations.

    Notes
    -----
    * Kiss64Random is used for all metrics in this wrapper
    * Seed must be non-zero; seed=0 is normalized to default_seed
    * State is fully deterministic given the seed
    """

    # 64-bit KISS random generator (used by default)
    cdef cppclass Kiss64Random nogil:
        # Type aliases
        ctypedef uint64_t result_type

        # Constants
        @staticmethod
        uint64_t default_seed

        # Constructors
        Kiss64Random() except +
        Kiss64Random(uint64_t seed) except +

        # Core methods
        void reset(uint64_t seed) except +
        void reset_default() except +
        void set_seed(uint64_t seed) except +
        uint64_t kiss() except +
        int flip() except +
        size_t index(size_t n) except +

        # Static helpers
        @staticmethod
        uint64_t get_default_seed() nogil

        @staticmethod
        uint64_t normalize_seed(uint64_t seed) nogil


# ==============================================================================
# Annoy Index Interface (Base Class)
# ==============================================================================

cdef extern from "annoylib.h" namespace "Annoy":
    """
    Core Annoy index interface.

    Template Parameters
    -------------------
    S : int32_t
        Index/item identifier type
    T : float
        Data element type (embedding values)
    Random : uint64_t
        Random number generator seed type

    Error Handling
    --------------
    Methods that can fail accept char** error parameter:
    * On success: return true/void, *error remains NULL
    * On failure: return false, *error points to allocated C string
    * Caller must free *error with free() if non-NULL
    """

    # Base interface for all Annoy index types
    cdef cppclass AnnoyIndexInterface[S, T, Random] nogil:
        """
        Abstract base interface for Annoy indices.

        Lifecycle
        ---------
        1. Construction: AnnoyIndex(f) where f > 0
        2. Building: add_item() repeatedly, then build()
        3. Querying: get_nns_by_item(), get_nns_by_vector()
        4. Persistence: save(), load(), serialize(), deserialize()
        5. Destruction: unload(), then delete

        State Transitions
        -----------------
        * EMPTY â†’ BUILDING: first add_item()
        * BUILDING â†’ BUILT: build()
        * BUILT â†’ BUILDING: unbuild()
        * BUILT â†’ LOADED: load()
        * Any â†’ EMPTY: unload()
        """

        # ==================== Core Building ====================

        cpp_bool add_item(S item, const T* embedding, char** error) except +
        """
        Add a vector to the index.

        Parameters
        ----------
        item : int32_t
            Non-negative item identifier
        embedding : const float*
            Pointer to f-dimensional float array
        error : char**
            Error message output parameter

        Returns
        -------
        success : bool
            True on success, False on failure (*error is set)

        Notes
        -----
        * Must be called before build()
        * Item IDs need not be contiguous but must be non-negative
        * Embedding pointer must remain valid during call
        * Not thread-safe during building phase
        """

        cpp_bool build(int n_trees, int n_threads, char** error) except +
        """
        Build the search forest.

        Parameters
        ----------
        n_trees : int
            Number of trees to build (-1 for auto-selection)
        n_threads : int
            Number of threads to use (-1 for all cores)
        error : char**
            Error message output parameter

        Returns
        -------
        success : bool
            True on success, False on failure

        Notes
        -----
        * Transitions index from BUILDING to BUILT state
        * After build(), index becomes read-only
        * Auto n_trees = max(2*f, 10) when n_trees=-1
        * Thread safety: build() itself is thread-safe for tree construction
        """

        cpp_bool unbuild(char** error) except +
        """
        Remove all trees to allow adding more items.

        Returns index to BUILDING state.
        """

        # ==================== Querying ====================

        void get_nns_by_item(
            S item,
            size_t n,
            int search_k,
            vector[S]* result,
            vector[T]* distances,
            char** error
        ) except +
        """
        Find nearest neighbors of a stored item.

        Parameters
        ----------
        item : int32_t
            Query item ID (must be < n_items)
        n : size_t
            Number of neighbors to return
        search_k : int
            Search effort (-1 for auto: n_trees * n)
        result : vector<int32_t>*
            Output: neighbor item IDs
        distances : vector<float>* or NULL
            Output: distances to neighbors (optional)
        error : char**
            Error message output parameter

        Notes
        -----
        * Requires BUILT state
        * result/distances are cleared and resized by this method
        * distances may be NULL if not needed
        """

        void get_nns_by_vector(
            const T* embedding,
            size_t n,
            int search_k,
            vector[S]* result,
            vector[T]* distances,
            char** error
        ) except +
        """
        Find nearest neighbors of a query vector.

        Similar to get_nns_by_item but queries by vector.
        """

        T get_distance(S i, S j) except +
        """
        Compute distance between two stored items.

        Parameters
        ----------
        i, j : int32_t
            Item IDs (must be < n_items)

        Returns
        -------
        distance : float
            Distance according to index metric

        Notes
        -----
        * Does not require BUILT state
        * For Hamming metric, distance is clipped to [0, f]
        """

        void get_item(S item, T* embedding) except +
        """
        Retrieve a stored embedding vector.

        Parameters
        ----------
        item : int32_t
            Item ID (must be < n_items)
        embedding : float*
            Output buffer (must have size >= f)

        Notes
        -----
        * embedding buffer must be pre-allocated by caller
        * Not thread-safe with concurrent add_item()
        """

        # ==================== Metadata ====================

        S get_n_items() nogil
        """Return number of items currently in the index."""

        S get_n_trees() nogil
        """Return number of trees (0 if not built)."""

        int get_f() nogil
        """Return embedding dimension."""

        # ==================== Persistence (Disk) ====================

        cpp_bool save(const char* filename, cpp_bool prefault, char** error) except +
        """
        Save index to disk file.

        Parameters
        ----------
        filename : const char*
            Output file path
        prefault : bool
            Whether to prefault pages during save
        error : char**
            Error message output parameter

        Returns
        -------
        success : bool
            True on success, False on failure

        Notes
        -----
        * Requires BUILT state
        * File is created or truncated
        * On failure, file may be partially written
        """

        cpp_bool load(const char* filename, cpp_bool prefault, char** error) except +
        """
        Load index from disk file.

        Parameters
        ----------
        filename : const char*
            Input file path
        prefault : bool
            Whether to prefault pages into memory
        error : char**
            Error message output parameter

        Returns
        -------
        success : bool
            True on success, False on failure

        Notes
        -----
        * Transitions to LOADED state
        * Dimension f must match file
        * Metric must match file
        * prefault=True may improve query latency at cost of load time
        """

        cpp_bool on_disk_build(const char* filename, char** error) except +
        """
        Enable on-disk building mode.

        Parameters
        ----------
        filename : const char*
            Build file path (will be truncated)
        error : char**
            Error message output parameter

        Returns
        -------
        success : bool
            True on success, False on failure

        Notes
        -----
        * Must be called before add_item()
        * Enables memory-efficient building for large indices
        * File is truncated on activation
        """

        void unload() except +
        """
        Unmap memory-mapped files and free memory.

        Transitions index to EMPTY state.
        Safe to call multiple times.
        """

        # ==================== Persistence (Memory) ====================

        vector[uint8_t] serialize(char** error) except +
        """
        Serialize index to bytes.

        Returns
        -------
        bytes : vector<uint8_t>
            Serialized index data

        Notes
        -----
        * Requires BUILT state
        * Returned vector is empty on error (check *error)
        * Suitable for in-memory transport or caching
        """

        cpp_bool deserialize(vector[uint8_t]* bytes, cpp_bool prefault, char** error) except +
        """
        Deserialize index from bytes.

        Parameters
        ----------
        bytes : vector<uint8_t>*
            Serialized index data
        prefault : bool
            Whether to prefault pages
        error : char**
            Error message output parameter

        Returns
        -------
        success : bool
            True on success, False on failure
        """

        # ==================== Configuration ====================

        void set_seed(Random seed) except +
        """
        Set random seed for index construction.

        Parameters
        ----------
        seed : uint64_t
            Random seed (0 uses default_seed)

        Notes
        -----
        * Must be called before build()
        * Seed is normalized: 0 -> default_seed
        * Affects tree construction randomness
        """

        void set_verbose(cpp_bool v) except +
        """
        Enable/disable verbose logging.

        Parameters
        ----------
        v : bool
            True to enable verbose output
        """


# ==============================================================================
# Concrete Annoy Index Types (Metric-Specific)
# ==============================================================================

cdef extern from "annoylib.h" namespace "Annoy":
    """
    Concrete instantiations of AnnoyIndex for each metric.

    Type Hierarchy
    --------------
    AnnoyIndexInterface<int32_t, float, uint64_t>
        â”œâ”€ AnnoyIndex<..., Angular, ...>     â†’ AnnoyAngularIndex
        â”œâ”€ AnnoyIndex<..., Euclidean, ...>   â†’ AnnoyEuclideanIndex
        â”œâ”€ AnnoyIndex<..., Manhattan, ...>   â†’ AnnoyManhattanIndex
        â”œâ”€ AnnoyIndex<..., DotProduct, ...>  â†’ AnnoyDotIndex
        â””â”€ HammingWrapperIndex               â†’ AnnoyHammingIndex

    Metric Definitions
    ------------------
    * Angular: 1 - (uÂ·v) / (||u|| ||v||)   [cosine-like, range [0, 2]]
    * Euclidean: ||u - v||_2                [L2 norm]
    * Manhattan: ||u - v||_1                [L1 norm, city-block]
    * Dot: -(uÂ·v)                           [negative dot product]
    * Hamming: popcount(u XOR v)            [bitwise distance, clipped to f]
    """

    # Forward declarations of metric types (defined in annoylib.h)
    cdef cppclass Angular nogil:
        pass

    cdef cppclass Euclidean nogil:
        pass

    cdef cppclass Manhattan nogil:
        pass

    cdef cppclass DotProduct nogil:
        pass

    cdef cppclass Hamming nogil:
        pass

    # Build policy types
    cdef cppclass AnnoyIndexSingleThreadedBuildPolicy nogil:
        pass

    cdef cppclass AnnoyIndexThreadedBuildPolicy nogil:
        pass

    # Generic AnnoyIndex template
    cdef cppclass AnnoyIndex[S, T, Distance, Random, ThreadedBuildPolicy](AnnoyIndexInterface[S, T, Random]) nogil:
        """
        Generic templated Annoy index.

        Template Parameters
        -------------------
        S : int32_t
            Index type
        T : float
            Data type
        Distance : {Angular, Euclidean, Manhattan, DotProduct}
            Metric type
        Random : Kiss64Random
            RNG type
        ThreadedBuildPolicy : {Single, Multi}ThreadedBuildPolicy
            Threading strategy
        """

        AnnoyIndex(int f) except +
        """
        Construct index with specified dimension.

        Parameters
        ----------
        f : int
            Embedding dimension (must be > 0)

        Raises
        ------
        std::bad_alloc
            If memory allocation fails
        """

    # Concrete typedefs matching Python extension
    ctypedef AnnoyIndex[int32_t, float, Angular, Kiss64Random, AnnoyIndexThreadedBuildPolicy] AnnoyAngularIndex
    ctypedef AnnoyIndex[int32_t, float, Euclidean, Kiss64Random, AnnoyIndexThreadedBuildPolicy] AnnoyEuclideanIndex
    ctypedef AnnoyIndex[int32_t, float, Manhattan, Kiss64Random, AnnoyIndexThreadedBuildPolicy] AnnoyManhattanIndex
    ctypedef AnnoyIndex[int32_t, float, DotProduct, Kiss64Random, AnnoyIndexThreadedBuildPolicy] AnnoyDotIndex

    # Hamming wrapper (special case: packs float embeddings into binary)
    cdef cppclass HammingWrapperIndex(AnnoyIndexInterface[int32_t, float, uint64_t]) nogil:
        """
        Hamming metric wrapper with float-to-binary packing.

        Embedding Interpretation
        ------------------------
        * Input: float array of length f
        * Each float is thresholded: val >= 0.5 â†’ 1, else â†’ 0
        * Packed into uint32_t or uint64_t words for efficient XOR
        * Distance is Hamming distance (popcount of XOR)
        * Distance is clipped to [0, f]

        Memory Layout
        -------------
        * f_external: user-facing dimension (float array length)
        * f_internal: packed dimension (ceil(f_external / bits_per_word))
        * Storage: f_internal * sizeof(InternalT) bytes per vector
        """

        HammingWrapperIndex(int f) except +
        """
        Construct Hamming index with specified dimension.

        Parameters
        ----------
        f : int
            Embedding dimension (number of bits; must be > 0)
        """

    ctypedef HammingWrapperIndex AnnoyHammingIndex


# ==============================================================================
# Helper Functions
# ==============================================================================

cdef extern from "annoylib.h" namespace "Annoy":
    """
    Utility functions for metric handling and validation.
    """

    # Metric string normalization (not exposed directly in annoylib.h,
    # but implemented in Python extension; we declare it here for completeness)
    pass


# ==============================================================================
# Memory Management Helpers
# ==============================================================================

cdef extern from "<cstdlib>" namespace "std" nogil:
    """
    C standard library memory management.

    Notes
    -----
    * Annoy uses char** error pattern: errors are allocated with strdup()
    * Python wrapper must free these with free() when non-NULL
    """

    void free(void* ptr)
    """Free memory allocated by C library (e.g., error strings)."""


cdef extern from "<cstring>" namespace "std" nogil:
    """
    C string manipulation.
    """

    char* strdup(const char* s)
    """Duplicate a C string (caller must free)."""
